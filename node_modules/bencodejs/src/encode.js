import {isArray} from './utils';

export default (function(){
    const END_MARKER = Buffer.from('e');
    const LIST_MARKER = Buffer.from('l');
    const DICT_MARKER = Buffer.from('d');
    const INTEGER_MARKER = Buffer.from('i');
    const buffer = [];
    let buffer_total_length = 0;
    let result = null;
    /**
     * @name encode
     * @desc Encodes data in the bencoded format.
     * @param obj{Object|Number|String|Array|Buffer}
     * @returns {Buffer}
     */
    function encode(obj){
        if(buffer.length) reset();
        _encode(obj);
        result = Buffer.concat(buffer, buffer_total_length);
        return result;
    }
    /**
     * @name reset
     * @desc Resets buffer.
     * @private
     */
    function reset(){
        buffer.length = 0;
        buffer_total_length = 0;
        result = null;
    }
    /**
     * @name _encode
     * @desc Encodes data in the bencoded format.
     * @param obj{Object|Number|String|Array|Buffer}
     * @private
     */
    function _encode(obj){
        if(Buffer.isBuffer(obj)){
            encode_byte_string(obj);
        } else if(typeof obj === 'string'){
            encode_char_string(obj);
        } else if(typeof obj == 'number'){
            encode_integer(obj);
        } else if(isArray(obj)){
            _encode_list(obj);
        } else {
            _encode_dict(obj);
        }
    }
    /**
     * @name encode_integer
     * @desc Encodes an integer in the form i{number in base 10}e
     * @param i {Number}
     * @private
     */
    function encode_integer(i){
        buffer.push(INTEGER_MARKER);
        buffer_total_length += INTEGER_MARKER.length;
        const integer = Buffer.from(parseInt(i, 10).toString());
        buffer.push(integer);
        buffer_total_length += integer.length;
        buffer.push(END_MARKER);
        buffer_total_length += END_MARKER.length;
    }

    /** @name encode_char_string
     *  @desc Encodes a character string.
     *  @param str{String}
     *  @private
     */
    function encode_char_string(str){
        encode_byte_string(Buffer.from(str));
    }
    /**
     * @name encode_byte_string
     * @desc Encodes a byte string (sequence of bytes, not necessarily characters) in the form {length of string in base 10}:{string}
     * @param buf{Buffer}
     * @private
     */
    function encode_byte_string(buf){
        const buf_length = buf.length;
        const str_length = Buffer.from(`${buf_length}:`);
        buffer.push(str_length);
        buffer_total_length += str_length.length;
        buffer.push(buf);
        buffer_total_length += buf_length;
    }
    /**
     * @name _encode_list
     * @desc Encodes a list in the form l{elements}e
     * @param list{Array}
     * @private
     */
    function _encode_list(list){
        const l = list.length;
        let i = 0;
        buffer.push(LIST_MARKER);
        buffer_total_length += LIST_MARKER.length;
        for(; i < l; i++)
            _encode(list[i]);
        buffer.push(END_MARKER);
        buffer_total_length += END_MARKER.length;
    }
    /**
     * @name _encode_dict
     * @desc Encodes a dictionary in the form d{list of alternating keys and their values}e
     * @param obj[Object}
     * @private
     */
    function _encode_dict(obj){
        const keys = Object.keys(obj).sort();
        const l = keys.length;
        let i = 0;
        buffer.push(DICT_MARKER);
        buffer_total_length += DICT_MARKER.length;
        for(; i < l; i++){
            const key = keys[i];
            encode_char_string(key);
            _encode(obj[key]);
        }
        buffer.push(END_MARKER);
        buffer_total_length += END_MARKER.length;
    }

    return encode;
})();